import retry from "async-retry";
import { promisify } from "util";
import { locator } from "./locator";
import { exec } from "child_process";
interface Comment {
  id: string;
  parent: string;
  text: string;
  like_count: number;
  author_id: string;
  author: string;
  author_thumbnail: string;
  author_is_uploader: boolean;
  author_is_verified: boolean;
  author_url: string;
  is_favorited: boolean;
  _time_text: string;
  timestamp: number;
  is_pinned: boolean;
}
interface CommentOutput {
  comments: Comment[];
}
/**
 * Prepares a comment object for output by ensuring it has necessary properties.
 *
 * @function pComment
 * @param {any} c - The raw comment object from the JSON output.
 * @returns {Comment} The processed comment object with specified fields.
 *
 * @example
 * const processedComment = pComment(someCommentObject);
 */
function pComment(c: any): Comment {
  return {
    id: c.id as string,
    parent: c.parent as string,
    text: c.text as string,
    like_count: c.like_count as number,
    author_id: c.author_id as string,
    author: c.author as string,
    author_thumbnail: c.author_thumbnail as string,
    author_is_uploader: c.author_is_uploader as boolean,
    author_is_verified: c.author_is_verified as boolean,
    author_url: c.author_url as string,
    is_favorited: c.is_favorited as boolean,
    _time_text: c._time_text as string,
    timestamp: c.timestamp as number,
    is_pinned: c.is_pinned as boolean,
  };
}
/**
 * Fetches and processes YouTube video comments for a given query.
 *
 * This function executes a command to retrieve comments using cprobe.exe, retries on failure,
 * and processes the comment data into a structured format.
 *
 * @function comEngine
 * @async
 * @param {Object} options - The options object.
 * @param {string} options.query - The YouTube video URL or query string.
 * @param {boolean} [options.sudo=false] - If true, runs with sudo privileges (optional).
 * @param {boolean} [options.useTor=false] - If true, routes the request through Tor (optional).
 * @returns {Promise<CommentOutput>} A promise resolving to an object containing the processed comments.
 * @throws {Error} Throws an error if the comment data cannot be fetched or parsed.
 *
 * @example
 * comEngine({ query: "https://www.youtube.com/watch?v=0rr45yQlVng", useTor: true }).then(output => {
 *   console.log(output.comments); // Array of processed comments
 * }).catch(error => {
 *   console.error(error); // Error message
 * });
 */
export default async function comEngine({ sudo = false, query, useTor = false }: { query: string; sudo?: boolean; useTor?: boolean }): Promise<CommentOutput> {
  const cprobe = await locator().then(fp => fp.cprobe);
  let pLoc = `${cprobe}`;
  const config = { factor: 2, retries: 3, minTimeout: 1000, maxTimeout: 3000 };
  if (useTor) pLoc += ` --proxy "socks5://127.0.0.1:9050"`;
  pLoc += ` --write-comments --dump-single-json "${query}"`;
  pLoc += ` --no-check-certificate --prefer-insecure --no-call-home --skip-download --no-warnings --geo-bypass`;
  pLoc += ` --user-agent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36"`;
  const metaCore = await retry(async () => {
    return await promisify(exec)(pLoc);
  }, config);
  const i = JSON.parse(metaCore.stdout.toString());
  return {
    comments: (i.comments || []).map(pComment),
  };
}

Now here is a code using engine.ts

import colors from "colors";
import { z, ZodError } from "zod";
import Tuber from "../../utils/Agent";
import { EventEmitter } from "events";
import type EngineOutput from "../../interfaces/EngineOutput";
/**
 * Defines the schema for the input parameters used in the `list_formats` function.
 *
 * @typedef {object} ListFormatsOptions
 * @property {string} query - The query string for the YouTube video.
 * @property {boolean} [verbose] - Whether to enable verbose logging.
 */
const ZodSchema = z.object({ query: z.string().min(2), verbose: z.boolean().optional() });
/**
 * Fetches the available formats for a YouTube video, including audio and video options,
 * and emits the data in a structured format.
 *
 * @function list_formats
 * @param {ListFormatsOptions} options - The options object containing query and settings.
 * @returns {EventEmitter} The event emitter to handle the `data`, `error` events.
 *
 * @example
 * const emitter = list_formats({ query: "Funny Video" });
 * emitter.on("data", data => console.log(data));
 */
export default function list_formats({ query, verbose }: z.infer<typeof ZodSchema>): EventEmitter {
  const emitter = new EventEmitter();
  (async () => {
    try {
      ZodSchema.parse({ query, verbose });
      const metaBody: EngineOutput = await Tuber({ query, verbose });
      if (!metaBody) {
        emitter.emit("error", "@error: Unable to get response from YouTube.");
        return;
      }
      emitter.emit("data", {
        ManifestLow: metaBody.ManifestLow.map(item => ({ format: item.format, tbr: item.tbr })),
        ManifestHigh: metaBody.ManifestHigh.map(item => ({ format: item.format, tbr: item.tbr })),
        AudioLow: metaBody.AudioLow.map(item => ({ filesizeP: item.filesizeP, format_note: item.format_note })),
        VideoLow: metaBody.VideoLow.map(item => ({ filesizeP: item.filesizeP, format_note: item.format_note })),
        VideoHigh: metaBody.VideoHigh.map(item => ({ filesizeP: item.filesizeP, format_note: item.format_note })),
        AudioHigh: metaBody.AudioHigh.map(item => ({ filesizeP: item.filesizeP, format_note: item.format_note })),
        VideoLowHDR: metaBody.VideoLowHDR.map(item => ({ filesizeP: item.filesizeP, format_note: item.format_note })),
        AudioLowDRC: metaBody.AudioLowDRC.map(item => ({ filesizeP: item.filesizeP, format_note: item.format_note })),
        AudioHighDRC: metaBody.AudioHighDRC.map(item => ({ filesizeP: item.filesizeP, format_note: item.format_note })),
        VideoHighHDR: metaBody.VideoHighHDR.map(item => ({ filesizeP: item.filesizeP, format_note: item.format_note })),
      });
    } catch (error: unknown) {
      switch (true) {
        case error instanceof ZodError:
          emitter.emit("error", error.errors);
          break;
        default:
          emitter.emit("error", (error as Error).message);
          break;
      }
    } finally {
      console.log(colors.green("@info:"), "â£ï¸ Thank you for using yt-dlx. Consider ðŸŒŸstarring the GitHub repo https://github.com/yt-dlx.");
    }
  })().catch(error => emitter.emit("error", error.message));
  return emitter;
}

You need to give me a new code for video_comments with this new comEngine.ts


Now please add filters for these comments like oldest, newest, etc. 
Use this code as the base on how the code should be structured.

import * as fs from "fs";
import colors from "colors";
import * as path from "path";
import { z, ZodError } from "zod";
import ffmpeg from "fluent-ffmpeg";
import Tuber from "../../utils/Agent";
import { EventEmitter } from "events";
import { locator } from "../../utils/locator";
/**
 * Defines the schema for the input parameters used in the `AudioCustom` function.
 *
 * @typedef {object} AudioCustomOptions
 * @property {string} query - The query string for the YouTube video.
 * @property {string} [output] - The output folder to store the result.
 * @property {boolean} [useTor] - Whether to use Tor for anonymization.
 * @property {boolean} [stream] - Whether to stream the output.
 * @property {string} [filter] - The audio filter to apply (e.g., "bassboost", "echo").
 * @property {boolean} [verbose] - Whether to enable verbose logging.
 * @property {boolean} [metadata] - Whether to include metadata.
 * @property {string} resolution - The resolution of the video ("high", "medium", "low", "ultralow").
 * @property {string} [filter] - Optional audio effect filter to apply.
 */
const ZodSchema = z.object({
  query: z.string().min(2),
  output: z.string().optional(),
  useTor: z.boolean().optional(),
  stream: z.boolean().optional(),
  verbose: z.boolean().optional(),
  metadata: z.boolean().optional(),
  resolution: z.enum(["high", "medium", "low", "ultralow"]),
  filter: z.enum(["echo", "slow", "speed", "phaser", "flanger", "panning", "reverse", "vibrato", "subboost", "surround", "bassboost", "nightcore", "superslow", "vaporwave", "superspeed"]).optional(),
});
/**
 * Processes a YouTube video query and applies audio effects (if any) while streaming or saving the result.
 *
 * @function AudioCustom
 * @param {AudioCustomOptions} options - The options object containing query and settings.
 * @returns {EventEmitter} The event emitter to handle progress, error, start, end, and stream events.
 *
 * @example
 * const emitter = AudioCustom({ query: "Funny Video", resolution: "high", filter: "bassboost", stream: true });
 * emitter.on("progress", progress => console.log(progress));
 */
export default function AudioCustom({ query, output, useTor, stream, filter, verbose, metadata, resolution }: z.infer<typeof ZodSchema>): EventEmitter {
  const emitter = new EventEmitter();
  (async () => {
    try {
      ZodSchema.parse({ query, output, useTor, stream, filter, verbose, metadata, resolution });
      const engineData = await Tuber({ query, verbose, useTor });
      if (!engineData) {
        emitter.emit("error", `${colors.red("@error:")} unable to get response!`);
        return;
      }
      const title = engineData.metaData.title.replace(/[^a-zA-Z0-9_]+/g, "_");
      const folder = output ? output : process.cwd();
      if (!fs.existsSync(folder)) fs.mkdirSync(folder, { recursive: true });
      const instance: ffmpeg.FfmpegCommand = ffmpeg();
      instance.setFfmpegPath(await locator().then(fp => fp.ffmpeg));
      instance.setFfprobePath(await locator().then(fp => fp.ffprobe));
      instance.addOption("-headers", `X-Forwarded-For: ${engineData.ipAddress}`);
      const resolutionFilter = resolution.replace("p", "");
      const adata = engineData.AudioHigh.find((i: { format: string | string[] }) => i.format.includes(resolutionFilter));
      if (!adata) {
        emitter.emit("error", `${colors.red("@error:")} no audio data found. use list_formats() maybe?`);
        return;
      }
      instance.addInput(engineData.metaData.thumbnail);
      instance.withOutputFormat("avi");
      instance.addInput(adata.url);
      const filenameBase = `yt-dlx_AudioCustom_${resolution}_`;
      let filename = `${filenameBase}${filter ? filter + "_" : "_"}${title}.avi`;
      const filterMap = {
        speed: ["atempo=2"],
        flanger: ["flanger"],
        slow: ["atempo=0.8"],
        reverse: ["areverse"],
        surround: ["surround"],
        subboost: ["asubboost"],
        superspeed: ["atempo=3"],
        superslow: ["atempo=0.5"],
        vibrato: ["vibrato=f=6.5"],
        panning: ["apulsator=hz=0.08"],
        phaser: ["aphaser=in_gain=0.4"],
        echo: ["aecho=0.8:0.9:1000:0.3"],
        bassboost: ["bass=g=10,dynaudnorm=f=150"],
        vaporwave: ["aresample=48000,asetrate=48000*0.8"],
        nightcore: ["aresample=48000,asetrate=48000*1.25"],
      };
      if (filter && filterMap[filter]) instance.withAudioFilter(filterMap[filter]);
      instance.on("progress", progress => emitter.emit("progress", progress));
      instance.on("error", error => emitter.emit("error", error.message));
      instance.on("start", start => emitter.emit("start", start));
      instance.on("end", () => emitter.emit("end", filename));
      if (stream && !metadata) {
        emitter.emit("stream", { filename: path.join(folder, filename), ffmpeg: instance });
        instance.output(path.join(folder, filename));
        instance.run();
      }
      if (!stream && metadata) {
        emitter.emit("metadata", { AudioLowDRC: engineData.AudioLowDRC, AudioLowF: engineData.AudioLowF, ipAddress: engineData.ipAddress, metaData: engineData.metaData, filename });
      }
    } catch (error: any) {
      switch (true) {
        case error instanceof ZodError:
          emitter.emit("error", error.errors);
          break;
        default:
          emitter.emit("error", error.message);
          break;
      }
    } finally {
      console.log(colors.green("@info:"), "â£ï¸ Thank you for using yt-dlx. Consider ðŸŒŸstarring the GitHub repo https://github.com/yt-dlx.");
    }
  })().catch(error => emitter.emit("error", error.message));
  return emitter;
}
